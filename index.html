<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Draggable Cubes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="build/three.js"></script>

		<script>

			var container;
			var camera, controls, scene, renderer, raycaster;
			var objects = [];

			var plane = new THREE.Plane();
			var planeIntersection = new THREE.Vector3();
			var worldPosition = new THREE.Vector3();
			var inverseMatrix = new THREE.Matrix4();

			var activeObject = null;
			var objectOffset = new THREE.Vector3();

			var mouse = new THREE.Vector2();

			var frustumSize = 1000;

			var scaleConstant = 15;
			var squareSize = 40;
			var globalObject = new THREE.Object3D();

			var highlightBox;
			var move = true;

			var rotateStart = new THREE.Vector3();
			var rotateEnd = new THREE.Vector3();

			init();
			animate();

			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 5, window.innerWidth / window.innerHeight, 1, 100000 );
				camera.position.z = 12000;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x050510 );
				scene.add( new THREE.AmbientLight( 0x505050 ) );

				pointLight = new THREE.PointLight( 0xffffff );
				pointLight.position.set(1,1,2);
				camera.add(pointLight);
				scene.add( camera );

				var geometry = new THREE.BoxBufferGeometry( squareSize, squareSize, squareSize );
				globalObject.position.x = 0;
				globalObject.position.y = 0;
				globalObject.position.z = 0;
				globalObject.scale.x = scaleConstant;
				globalObject.scale.y = scaleConstant;
				globalObject.scale.z = scaleConstant;
				globalObject.name = "global";

				highlightBox = new THREE.Mesh(
					new THREE.SphereBufferGeometry( 1.5 , 32, 32 ),
					new THREE.MeshLambertMaterial( {
						emissive: 0xffff00,
						transparent: true,
						opacity: 0.5
					} )
				);
				highlightBox.visible = false;

				for ( var i = 0; i < 50; i ++ ) {
					var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0x808080 } ) );

					object.position.x = Math.random() * ( 2 * scaleConstant ) - scaleConstant;
					object.position.y = Math.random() * ( 2 * scaleConstant ) - scaleConstant;
					object.position.z = Math.random() * ( 2 * scaleConstant ) - scaleConstant;

					object.rotation.x = Math.random() * 2 * Math.PI;
					object.rotation.y = Math.random() * 2 * Math.PI;
					object.rotation.z = Math.random() * 2 * Math.PI;

					object.scale.x = 0.1;
					object.scale.y = 0.1;
					object.scale.z = 0.1;

					object.castShadow = true;
					object.receiveShadow = true;

					object.name = i;

					globalObject.add( object );
					objects.push( object );
				}
				highlightBox.position.x = 0;
				highlightBox.position.y = 0;
				highlightBox.position.z = 0;

				highlightBox.scale.x = 20;
				highlightBox.scale.y = 20;
				highlightBox.scale.z = 20;

				globalObject.add( highlightBox );
				scene.add( globalObject );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFShadowMap;

				container.appendChild( renderer.domElement );

				raycaster = new THREE.Raycaster();

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'mouseup', onDocumentMouseCancel, false );
				document.addEventListener( 'dblclick', onDocumentDblClick, false );
				document.addEventListener( 'wheel', onMouseWheel, false );

				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onDocumentMouseMove( event ) {
				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
				raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( globalObject.children );
				if ( activeObject ) {
					if ( move == true ) {
						//Processamento de objetos individuais
						if ( intersects.length > 0 ) {
							var rect = renderer.domElement.getBoundingClientRect();
							if ( activeObject  ) {
								if ( raycaster.ray.intersectPlane( plane, planeIntersection ) ) {
									activeObject.position.copy( planeIntersection.sub( objectOffset ).applyMatrix4( inverseMatrix ) );
								}
							}
						}
					} else {
						//Processamento de rotação
						//Tentar pegar a posição do mouse em função da distância x e y do objeto ao invés de ser do centro da tela
						var quatRot = new THREE.Quaternion();

						rotateEnd.set( mouse.x, mouse.y, 0 );
						rotateStart.normalize();
						rotateEnd.normalize();

						quatRot.setFromUnitVectors( rotateStart, rotateEnd );
						rotateStart.copy( rotateEnd );

						activeObject.applyQuaternion( quatRot );
					}

				}

			}

			function onDocumentDblClick( event ) {
				event.preventDefault();

				raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( globalObject.children );

				if ( intersects.length > 0 ) {
					if ( move == true ) {
						//Se encontrou um objeto e está trocando para rotação, deverá ativar a orb
						move = false;
						var untagObject = scene.getObjectByName( "active" );
						try{ untagObject.name = "" } catch (e) {}
						intersects[ 0 ].object.name = "active";
						var targetDistance = intersects[ 0 ].distance;
						highlightBox.visible = true;
						highlightBox.position.copy( intersects[ 0 ].object.position );
						//highlightBox.position.multiplyScalar( scaleConstant );
						highlightBox.scale.copy( intersects[ 0 ].object.scale )
						highlightBox.scale.multiplyScalar( 2 * squareSize / 3 );
					} else {
						//Se encontrou um objeto e está trocando para mover, deverá ocultar a orb
						highlightBox.visible = false;
						move = true;
					}
				} else {
					if ( move == true ) {
						//Se não encontrou nenhum objeto e está trocando para rotação, deverá ativar a orb
						var untagObject = scene.getObjectByName( "active" );
						try{ untagObject.name = "" } catch (e) {}
						highlightBox.visible = true;
						move = false;
						highlightBox.position.copy( globalObject.position );
						highlightBox.scale.copy( globalObject.scale );
						highlightBox.scale.multiplyScalar( 1.5 );
						globalObject.name = "active";	
					} else {
						//Se não encontrou nenhum objeto e está trocando para mover, deverá ocultar a orb
						highlightBox.visible = false;
						move = true;
					}
				}
			}

			function onDocumentMouseCancel( event ) {
				event.preventDefault();

				if ( activeObject ) {
					activeObject = null;
				}
			}

			function onDocumentMouseDown( event ) {
				event.preventDefault();

				raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( globalObject.children );

				if ( move == true ) {
					//Processamento de objetos individuais
					if ( intersects.length > 0 ) {
						activeObject = intersects[ 0 ].object;
						plane.setFromNormalAndCoplanarPoint( camera.getWorldDirection( plane.normal ), worldPosition.setFromMatrixPosition( activeObject.matrixWorld ) );
						if ( raycaster.ray.intersectPlane( plane, planeIntersection ) ) {
							inverseMatrix.getInverse( activeObject.parent.matrixWorld );
							objectOffset.copy( planeIntersection ).sub( worldPosition.setFromMatrixPosition( activeObject.matrixWorld ) );
						}
					}
				} else {
					//Processamento de rotação
					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
					activeObject = scene.getObjectByName( "active" );
					rotateStart.set( mouse.x, mouse.y, 0 );
				}
			}

			function onMouseWheel( event ) {
		        var delta;
		        if (event.wheelDelta){
		            delta = event.wheelDelta;
		        }else{
		            delta = -1 * event.deltaY;
		        }
		        camera.position.z = camera.position.z - ( delta * 5 );
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
			}

			function render() {
				renderer.render( scene, camera );
			}

		</script>
	</body>
</html>
